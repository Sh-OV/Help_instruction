# ИНСТРУКЦИЯ по работе с LINUX

## Урок 1. Основы Linux
!!! Linux это UNIX подобная система
### Системные вызовы в Linux
1. Управление процессами:
    - ps afx - вывод списка процессов (ps - опция процессов, для более подробной справки введи команду ps --help all)
    - fork() – создание нового процесса клонированием
    - exec() – запуск программы
    - exit() – завершение программы
2. Управление файлами:
    - open() – открыть файл
    - read() – прочитать данные из файла
    - write() – записать данные в файл
    - close() – закрыть файл

### Установка пакетов в Ubuntu
- sudo apt update – обновить список пакетов
- sudo apt install mc – установить пакет mc
- sudo apt install openssh-server – установить SSH-сервер

### Сетевые режимы VirtualBox
- Мост (bridge) – ВМ в локальной сети, прямой доступ к ВМ по IP.
- NAT – ВМ в своей сети, доступ к машине только через проброс портов.
        При пробросе портов (создаем порт, протокол - TCP, Порт хоста - 8022, Порт гостя - 22)

### Установка гостевых дополнений VB в Ubuntu
- sudo apt update – обновить список пакетов
- sudo apt install perl gcc make – установить пакеты
- Запуск установки гостевых дополнений

### Команды для подключения сети:
- ip a      - покажет список сетевых интерфейсов
- systemctl status ssh          - проверяем статус сервисов (подключения)
- ssh olga@192.168.0.108        - подключение (по мосту (bridge) к удаленному   пользователю, в нашем случае к Windows PowerShell)
- ssh -p 8022 olga@localhost    - подключение NAT (при беспроводном интернете) с помощью проброса портов

------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------

## Урок 2. Работа с файлами в терминале

### Что такое оболочка
Пользователь    ->  Оболочка (Bash) ->  Операционная система
Оболочка - посредник (переводчик) между пользователем и операционной системой

### Приглашение оболочки Bash
Пример записи:  olga@olga-VirtualBox-linux:~$
Расшифровка:    "имя пользователя(логин)"(olga) @ "имя компьютера(хоста)"(olga-VirtualBox-linux) : "текущий каталог"(~ (домашний католог)) "тип пользователя"($ (обычный пользователь))
    $   - обычный пользователь
    #   - суперпользователь с правами root
Чтобы подключиться с правами суперпользователя вводим команду
    :~$ sudo su
Чтобы выйти вводим команду
    :~# exit

### Домашняя директория:
- Обычно /home/{user}
- Документы пользователя
- Настройки пользователя
- Общие настройки системы /etc
- Обозначается как ~
### Переходы по директориям:
- :~$ cd /          - переход в корневой каталог
- :~$ cd ..         - переход на уровень вверх
- :~$ cd ../..      - переход на два уровня вверх
- :~$ cd            - переход в домашнюю директорию
- :~$ cd ~          - переход в домашнюю директорию
- :~$ cd name_dir   - переход к каталогу name_dir

### Специальные файловые системы:
- /dev — устройства
- /proc — процессы и состояние ОС
    ○ /proc/cpuinfo — процессор
    ○ /proc/version — версия ОС
- /sys — информация о системе
- /run — временные файлы состояния

### Тип файлов:
Тип файла:              Обозначение (ls)      Обозначение (mc)    Описание типа
Обычный файл                    -                   нет             файл на диске
Директория                      d                   /               файл со списком элементов
Блочное устройство              b                   +               дисковый накопитель
Символьное устройство           c                   -               посимвольно (например терминал VSCode)
UNIX-сокет                      s                   =               файл 0 бит, заменяющий TSP
Именованный канал               p                   |               как сокет, но др. функционал 
Символическая ссылка            l                   @ и ~

### Работа с файлами
- ls — список файлов
    ○ ls -al        — подробный список файлов
    ○ ls --help     — справка по команде ls
    ○ man ls        — мануал для утилиты ls (более развернуто, чем --help)
- pwd — текущая директория  (выдает полный путь к директории)
- mkdir — создание каталога     (не сможет создать несколько каталогов "матрешку" (например 1/2/3/4/5 ))
    ○ mkdir -p  1/2/3/4/5    — создаст весь путь и всю "матрешку" (если таких каталогов нет) до последнего 5 каталога
- cp — копирование
    ○ cp test1 test2          — копирует файл test1 в файл test2 который создает при копировании
    ○ cp -r test test3        — копирует каталог test в каталог test3 который создает при копировании (где -r  - рекурсия)

- rm — удаление
    ○ rm -f name_file         — удаляет файл без дополнительных вопросов
    ○ rm -rf name_dir         — удаляет каталог (директорию) без дополнительных вопросов
    ○ rm -- -foo
!!! Рекомендуется прописывать полный путь к файлу или директории, которую надо удалить, т.к. команда опасная, а полный путь помогает избежать ошибок
- mv — переименование/перенос
    ○ mv test1 test4          — переименует файл test1 в test4, т.к. источник и назначение находятся в одной файловой системе
- touch — создание пустого файла
- cat — вывод файла, склейка, создание
    ○ cat name_file                     — вывод файла
    ○ cat name_file1 name_file2         - вывод нескольких файлов (двух в данном примере) - пишутся поочередно через пробел
    ○ cat test1 test2 > test_all        — склейка двух файлов с созданием нового файла, состоящего из первых двух (можно склеить много файлов (пишем их до угловых скобок через пробел))
    ○ cat > name_file                   — создание файла (с записью в него данных) Ctrl+D - закроет запись в файл
    ○ cat >> name_file                  — дозаписывет файл не перезаписывая его полностью. Ctrl+D - закроет запись в файл
- df     —  Показывает сведения о файловой системе, на которой расположен каждый из ФАЙЛОВ, или, по умолчанию, обо всех файловых системах. Не важно в какой директории будет запущена - отобразит всю файловую систему от корня
    ○ df -h                             — выводит размеры в степени 1024 (например, 1023M)

### Относительные и абсолютные пути
- Абсолютные:
    ○ начинаются с корня /
    ○ всегда указывают на один и тот же объект
    ○ cat /var/log/syslog
    !!! Абсолютный путь всегда будет указывать на конкретный файл, даже если, например файл с абсолютной ссылкой переместить, он ксе равно будет указывать на этот файл 
- Относительные:
    ○ не начинаются c /
    ○ зависят от текущего положения
    ○ cat test/testfile
    !!! Относительный путь будет указывать на конкретный файл до тех пор, пока , например файл с относительной ссылкой не переместили в другую директорию, при перемещении относительная ссывлка сломается

### Жёсткие ссылки
Схема жесткой ссылки:
                    Имя 1-го файла в директории и Имя 2-го файла в директории <- жестакя ссылка -> Индексный дескриптор inode (метаданные)  <-> Данные на диске
- inode     — небольшая структура данных, в которой описаны метаданные про наш элемент в файловой системе (м/б каталог, файл и т.п.). Он знает все, кроме названия файла. Жесткая сслка это связь между именем файла и inode, а дальше inode ведет к данным на диске. Пока существует хотя бы одна жесткая ссылка этот inode будет рабочим.
!!! Жесткие ссылки могут работать только в одной файловой системы (в рамках одного раздела жесткого диска). 
!!! При изменении данных в одном из файлов, связанных жесткой ссылкой, изменения вносятся в оба файла, т.к. имеют один inode
!!! Не допускается создавать жесткие ссылки на каталоги
!!! Жесткие ссылки имеют применение в резервном копировании
!!! При жесткой ссылке реально не создается несколько файлов, а имеется один и тот же inode с несколькими названиями
    Пример: 
            - :~$ ln file1 file_ln     — создает жёсткую ссылку file_ln на file1 (у обоих файлов одна и та же ссылка на один inode)
            - :~$ ln -ali              — посмотреть информацию об inode (номер в первом столбце - inode)

### Символические ссылки
Схема символической ссылки:
 Имя 1-ой символической ссылки и Имя 2-ой символической ссылки <- символическая ссылка -> Имя файла или директории (абсолютный или относительный путь) <-> Индексный дескриптор inode (метаданные)  <-> Данные на диске
!!! Символическая ссылка это отдельный тип файла (буква l (в ls))
!!! Символическая ссылка ссылается не на inode, а на имя другого файла или каталога
!!! Символические ссылки можно делать и на файлы и на каталоги
!!! Символические ссылки можно делать как в пределах одной файловой системы, так и за ее пределами - никаких ограничений нет!
!!! Но - каждая символическая ссылка будет занимать собственный inode 
!!! Символическая ссылка - это файл в котором прописан путь
    Пример: 
            - :~$ ln -s file1 file_lns      — создает символическую ссылку file_lns на file1 
            - :~$ ln -ali                   — посмотреть информацию об inode (номер в первом столбце - inode)
!!! При внесении изменения в файл file_lns (cat >> file_lns) с ним ничего не произойдет, а изменения появятся в файле file1

## Текстовые редакторы

### Текстовый редактор Vim
- Командный режим (Esc)
    ✖ навигация по файлу
    ✖ копирование и вставка
    ✖ удаление символов и строк
    ✖ поиск текста
- Режим редактирования (I, A, O, Insert)
    ✖ ввод и редактирование текста
    как в обычных редакторах
- Режим последней строки (: (двоеточие))
    ✖ сохранение файла (w)
    ✖ выход из редактора (q)
    ✖ изменение настроек (set)

### Текстовый редактор Nano
    ● Cправка — Ctrl+G
    ● Сохранение файла — Ctrl+O
    ● Выход — Ctrl+X
    ● Включение номеров строк — Alt+N
    ● Поиск — Ctrl+W

### Текстовый редактор Mcedit
    ● Cправка — F1
    ● Сохранение файла — F2
    ● Выход — F10 или Esc+Esc
    ● Включение номеров строк — Alt+N
    ● Поиск — F7
    ● Выделение блока — F3
    ● Меню — F9
    ● Копировать в файл — Ctrl+F
    ● Вставить файл — Shift+F5

### Терминальные пейджеры less и more
- less
    ✖ прокрутка: PgUp, PgDown, курсор
    ✖ поиск: / и ?
    ✖ справка: H
- more
    ✖ прокрутка: Enter, пробел
    ✖ поиск: / и ?
    ✖ справка: H

### head и tail
- head — начало файла
    Пример: 
        :~$ head -n 10 .profile     (посмотреть файл .profile первые 10 строк)
- tail — конец файла
    Пример: 
        :~$ tail -n 10 .profile     (посмотреть файл .profile последние 10 строк)
        :~$ tail -f .profile        (позволяет отслеживать изменения файл .profile)

------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------

## Урок 3. Права доступа и пользователи

### Классификация пользователей в Linux
- Суперпользователь (root)
    ● UID = 0
    ● Home /root
    ● Пароль не всегда
    ● Есть shell
    ● Неограниченные полномочия
- Обычный пользователь (user)
    ● UID > 1000
    ● Home /home/user
    ● Пароль установлен
    ● Есть shell
    ● Доступ в рамках домашней директории
- Системный пользователь (daemon)
    ● 1 < UID < 1000
    ● Home Любая
    ● Пароля нет
    ● Нет shell
    ● Ограниченный доступ

### Атрибуты пользователя в Ubuntu
● UID – user ID                 ● 1000
● GID – group ID                ● 1000
● Домашняя директория (home)    ● /home/{user}
● Логин (login)                 ● {user}
● Пароль (password)             ● *****
● Оболочка (shell)              ● /bin/bash

### Некоторые команды:
- id                            - показывает где мы находимся, какой пользователь,  какая группа и какие группы есть вообще
- sudo id t_user                - то же что и id, только для другого пользователя
- cat /etc/passwd               - просмотр перечня пользователей, подключенных к системе
- sudo cat /...                 - если отказано в доступе, можно попробовать через sudo (может запросить пароль)

### Хранение данных о пользователях:
- /etc/passwd – список пользователей
- /etc/group – группы пользователей
- /etc/shadow – пароли пользователей

### Управление пользователями:
- useradd – создание пользователя
    Пример:  
        :~$ sudo useradd -s /bin/bash -m -d /home/testuser t_user (где: -s /bin/bash (параметр shell (оболочка)), -m (домашняя директория), -d /home/testuser (точный путь для домашней директории), t_user (логин пользователя))
- adduser – создание пользователя (скрипт)
    Пример: 
        :~$ sudo adduser t_user2 (где: t_user2 (логин пользователя)) - при запуске скрипт сразу создаст все параметры и даже попросит установить пароль для пользователя
- usermod – изменение пользователя (например поместить его в дополнительную группу, поменять его основную группу и т.д.)
    Пример: 
        :~$ sudo usermod -aG adm t_user     (где -a (append (добавитель)), G (список дополнительных групп), adm (название группы), t_user (пользователь)) - если пользователь активен в тот момент когда его добавили в группу, то добавление произойдет после его выхода из текущей сессии
    Пример: 
        :~$ sudo usermod -g www-data t_user (где -g (изменение основной группы),  www-data (название группы), t_user (пользователь))
    Другие изменение можно посмотреть в мануале :~$ man usermod
- userdel – удаление пользователя
    Пример: 
        :~$ sudo userdel t_user2    (удалит пользователя, но не удалит домашнюю директорию, для удаления директории нужно указать параметр -r)
- passwd – изменение пароля
    Пример: 
        :~$ sudo passwd t_user
- chage – изменение свойств пароля
    Пример: 
        :~$ sudo chage t_user
- groupadd – создание группы
    Пример: 
        :~$ sudo groupadd testgroup
    !!! посмотреть перечень групп можно в в файле /etc/group        
        Пример: 
            :~$ cat /etc/group
- groupdel – удаление группы
    Пример: 
        :~$ sudo groupdel testgroup
- Если мы захотим запретить пользователю доступ, то перед паролем в  /etc/shadow необходимо поставить восклицательный знак'!'
- Для возврата доступа пользователю - восклицательный знак удаляется, пароль остается тем же

### Механизм sudo и su:
- su – переключение пользователя
- sudo su – переключение на суперпользователя (root)
- sudo – выполнение команды с правами суперпользователя
- /etc/sudoers – конфигурация sudo
- visudo – редактирование       (файла /etc/sudoers.tmp для внесения изменений в права root, admin, sudo и т.п.)
    ● root    ALL=(ALL:ALL) ALL     (в файле sudoers суперпользователь root имеет максимальный допуск ко всему (судя по формуле))
    ● %admin ALL=(ALL) ALL          (группа admin (% - обозначает группу) )
    ● %sudo   ALL=(ALL:ALL) ALL     (группа sudo имеет максимальный допуск ко всему (судя по формуле))
    Формула ALL=(ALL:ALL) ALL означает что можно исполнять команды с использованием любого пользователя, с любой группой и набор комманд не ограничен (последняя ALL)
    Если необходимо выдать права на какие-то конкретные команд, то вместо ALL прописываются разрешения
        Например:
            %admin ALL=(ALL) /user/bin/passwd       (такой пользователь сможет менять пароль кому угодно, но больше ничего не сможет)
            %admin ALL=(ALL) NOPASSWD:ALL           (такая команда отменит введение паролей у данной группы)
        Прописав группу в файле sudoers и обозначив права для этой группы, мы потом в нее добавляем пользователь для выдачи им этих прав

### Изменение владельца и группы владельца файлов:
- chown – изменение владельца и группы          !!! опасная команда, т.к. может повлечь за собой много проблем, особенно Рекурсия
    ○ chown -R – рекурсивно             (замена владельца во всей директории (каталоге))
        Пример: :~$ sudo chown -R t_user:www-data /home/olga/test3     (команду пишем в нужной директории)
    ○ chown testuser:testgroup          (замена владельца и группы для конкретного файла в директории)
        Пример: :~$ sudo chown t_user:www-data test     (команду пишем в нужной директории)
    ○ chown testuser                    (замена владельца для конкретного файла)
- chgrp – изменение группы
    ○ chgrp -R –рекурсивно
        Пример: :~$ sudo chgrp -R adm /home/olga/test3
    ○ chgrp testgroup

### Права доступа для файлов и директорий:
!!!  r - чтение, w - запись, x - исполнение
!!!  x - исполнение ставится только у директорий, у файлов бит на исполнение не ставится!!!
- rwx   - владелец (совпадение пользователя)
- r-x   - группа (пользователь в группе)
- r--   - остальные (все остальные пользователи)
-При числовой форме записи: 4 - бит чтения (4 = r), 2 - бит записи (2 = w), 1 - бит исполнения (1 = x) 
    ○ 7 = 4+2+1 = rwx
    ○ 6 = 4+2   = rw-
    ○ 5 = 4+1   = r-x 

### Специальные биты
!!! Специальные биты применяются для узко-специальных задач 
- SUID          - (бит, который выставляет user id (UID) при выполнении файла)
    4000        - (обозначение в восьмеричной форме)
    ✖ для исполняемых файлов
    ✖ запуск программы от имени владельца файла
    -rwsr       - (если на третьем месте стоит s, значит выставлен бит SUID. Если на том же месте стоит S, это значит, что SUID бит установлен, но нет бита на исполнение, т.е. особого смысла в этом нет, т.к. файл не исполняемый для владельца)
        Пример: sudo chmod u+s neme_file        (выставление спец бита (SUID))
    !!! Этот бит (SUID), запускает файл не с правами Вашего пользователя, а с правами владельца файла (в основном это используется для запуска программы от root, при этом Вы можете быть обычным пользователем, не иметь никаких прав для sudo, но программа запустится с правами root (например при смене пароля, у себя, у всех пользователей права root))
- SGID          - (предназначен для директорий и позволяет создавать файлы, у которых группа будет назначена от группы этого каталога)
    2000
    ✖ для директорий
    ✖ создание файлов с группой, назначенной для директории
    -sr
        Пример: sudo chmod g+s neme_dir         (выставление спец бита (SGID))
- Sticky bit    - (позволяет для директорий разрешить удаление файлов только для создателей этого файла, либо для владельцев этой директории)
    1000
    ✖ для директорий
    ✖ удаление файлов только владельцем файла или директории
    -t
    !!! Применимо там, где широкие права доступа для каталога и чтобы один пользователь не смог удалять файлы другого пользователя

### Изменение прав доступа:
- chmod — change mode, изменение прав доступа       !!! опасная команда т.к. может повлечь за собой неработоспособность какого-то компонента, особенно Рекурсия
    ○ chmod -R testdir/ – рекурсивно                        (изменение прав доступа ко всем файлам во всей директории (каталоге))
        Пример: sudo chmod -R o=rx test3/               (права доступа для всех файлов в директории test3/ стали для остальных r-x)
    ○ chmod u=rwx,g=rx,o=r testfile – символьная форма      (формат символьной записи прав доступа где u - владелец, g  - группа, o - остальные)
        Пример: sudo chmod u=rwx,g=rw,o=rx test2        (права доступа: -rwxrw-r-x)
                sudo chmod u+rwx,g=rw,o-rx test2        (права доступа: -rwxrw----)
    ○ chmod 751 testfile – числовая форма                   (где 7 - права доступа для владельца (7=rwx), 5 - права доступа для группы, 1 - для остальных)
            Пример: sudo chmod 664 test2                (права доступа: -rw-rw-r--)
    ○ chmod a+x – изменение для всех                        (chmod a+x -способ указать биты для всех, либо просто chmod +x -это добавит бит на исполнение для всех трех групп (для владельца, для группы и для остальных))
    ○ chmod 4755 – изменение специальных битов      (где: 4 -SUID бит, 755 - обычные основные биты)

### Права по умолчанию и umask:
    Назначение:             Файлы:      Директории:
    Полные права            666         777
    Значение umask          022         022         (umask - это понижение прав доступа)
    Права по умолчанию      644         755         (получаем путем вычитания каждого бита (из полных прав вычитаем umask))
!!! Значение umask
    Пример:
        :~$ umask 
        :~/name_dir$ umask 002       (установить значение umask для конкретной директории)
        :~/$ umask 022               (установить значение umask для все домашней директории)  

------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------

## Урок 4. Скрипты Bash

### Bash — язык программирования
- Интерпретатор — /bin/bash
- Переменные
- Условия
- Циклы
- Функции
- Однострочные скрипты

### Код возврата (завершения) — exit code
- Код ошибки последней команды      (если exit code (код ошибки (м.б. от 0 до 255)) = 0, значит ошибки не было, если код отличен от 0, значит ошибка была)
- Проверить: echo $?                (где: ? - переменная, $ - обращение к переменной (знак переменной), echo - команда, для вывода в консоль значения предыдущей команды)
- условные связки выполнения нескольких команд:
    - Условная связка (И): ls -al && echo "Success!"        (выполняет вторую команду в случае успешного выполнения первой команды)
    - Условная связка (ИЛИ): ls -al || echo "Fail!"         (выполняет вторую команду в случае ошибки выполнения первой команды)
!!! Можно объединять сколько угодно команд в однострочные скрипты и выполнять их в рамках одной команды
### Потоки ввода-вывода
!!! Имеется три стандартных потока ввода - вывода:
STDIN (0) ввод  --> cat --> STDOUT (1) вывод (или STDERR (2) ошибки)
    STDIN -     Стандартный поток ввода, имеет номер 0 (номер мы будем использовать для обращения к потокам) Это поток, который поступает в процессор, в примере программа cat 
                Обычно стандартный поток ввода привязан к клавиатуре
    STDOUT -    Стандартный поток вывода, имеет номер 1. Обычно это текстовый поток данных, который выводится в терминал, может быть выведен в файл
    STDERR -    Сандартный поток ошибок, имеет номер 2. Обычно это текстовый поток данных, который выводится в терминал, может быть выведен в файл
### Перенаправление потоков ввода-вывода
!!!Если стрелка смотрит в сторону program, это поток ввода, если стрелка направлена от program, то это поток вывода:
- program < file – перенаправление ввода из файла file в программу
- program > file – перенаправление вывода (STDOUT) в файл file (запись с начала файла (все, что было записано ранее - будет удалено)) - если файла не было, то он будет создан (при наличия прав доступа к директории)
- program >> file – перенаправление вывода (STDOUT) в файл file в режиме дополнения файла (все, что было записано ранее - будет оставлено в файле)
- program 2> file – перенаправление ошибок (STDERR) в файл file (запись с начала файла)
- program 2>> file – перенаправление ошибок (STDERR) в файл file в режиме дополнения файла
- program > file 2>&1 – перенаправление вывода (STDOUT) и ошибок (STDERR) в файл file - объединение стандартного потока вывода и потока ошибок в один файл. Запись 2>&1 означает объединение двух выходов в один (а файлов может быть объединено сколько угодно)
(запись с начала файла)
    Примеры :
        :~$ ls > ls_txt         - перенаправили команду ls в файл ls_txt
        :~$ ls >> ls_txt        - перенаправили команду ls и  дозаписали ее в файл ls_txt
        :~$ cat /etc/lsb-release /etc/shadow     - т.к. к файл /etc/shadow нет доступа, то на выходе получаем и поток вывода и поток ошибок одновременно
        :~$ cat /etc/lsb-release /etc/shadow 2> err.txt     при такой записи в терминал выведется только первый выход, а второй сохраниться в файле (не важна последовательность читаемых файлов)
        :~$ cat /etc/lsb-release /etc/shadow 2> err.txt > std.txt     при такой записи в терминал ничего не выведется, второй выход сохраниться в файле  err.txt, а первый выход - в файле std.txt
        :~$ cat /etc/lsb-release /etc/shadow > all.txt     при такой записи первый выход запишется в файл all.txt, а второй выход выведется в терминале
        :~$ cat /etc/lsb-release /etc/shadow  > all.txt 2>&1     при такой записи оба выхода запишутся в файл all.txt

### Конвейер (pipeline, pipe)
!!! Конвейер - очень мощная функциональность, которая позволяет решать крайне сложные задачи прямо в командной строке (без спец. инструментов)
!!! В конвейере может быть от двух до неограниченного количества команд последовательно.
- pipeline -    схема (конструкция) конвейера
- pipe -        символ |
- Перенаправление ввода-вывода между процессами
!!! стандартный поток вывода первой команды направляется в стандартный поток ввода второй команды и т.д. слева - направо от первой команды до последней
!!! При этом каждая из этих команд обрабатывает входные данные и выдает какой-то свой результат в следующую команду
- grep —        утилита фильтрации по заданному значению 
    - grep -v 'name'      выбирать не подходящие строки (т.е. будут выбраны все строки, где нет name) 
    - grep -i 'name'      игнорировать различие регистра
!!! утилита grep применима для любых задач, которые работают с текстом (фильтровать можно любые списки (список процессов, список файлов, содержимое файла и т.д.))
!!! утилита grep может работать как в обычном режиме сравнения стандартных строк, так и в режиме регулярных выражений 
- wc -l —       утилита  ворд каунт которая с l (эль) показывает количество строк
- sort —        утилита сортировки
!!! Когда мы создаем конвейер, каждая программа (утилита) которая там есть, может работать параллельно с другой - мы можем использовать возможности многоядерного процессора, чтобы выполнять эту задачу эффективно. За счет этого мы получаем возможность обрабатывать тяжелые данные 
    Примеры :
        :~$ ls -al | grep txt                   - отфильтрует список, который выводится командой ls -al и покажет только те документы, где в названии есть txt
        :~$ ps afx | grep ssh | grep -v pts     - возьмет список процессов, отфильтрует их по слову ssh и уберет из выводимого списка все строки, где содержится pts
        :~$ ps afx | grep [s]sh                 - возьмет список процессов, отфильтрует их по слову ssh, обрамление первой буквы квадратными скобками говорит о том, что мы хотим найти символьный класс, который состоит из одного символа (где ssh стоит в начале строки)
        :~$ ls -al | grep -P '\.[cs]+'        - используем шаблон для команды grep это -P (регулярные выражения языка Perl) и внутри используем шаблон в одинарных кавычках(экранируем точку (\.) и задаем символьный класс ([cs]) и добавляем квантификатор (+), где плюс говорит что дальше должен быть хотя-бы один символ (либо c либо s))
        :~$ cat /var/log/syslog | grep 'mysql' | grep -v 'file' | wc -l     - берет файл syslog, фильтрует по значению mysql, ищет строки, в которых нет file и отправляет на утилиту wc -l, которая может посчитать количество строк
        :/var/log$ ls -al | cat syslog |grep error | grep -v systemd    - открыли каталог log, нашли и посмотрели файл syslog, отфильтровали по error и вывели все, где нет systemd
        :~$ cat /var/log/syslog |grep error | grep -v systemd           - то же самое, что и предыдущая строчка, только из домашнего каталога
        :~$ cat /var/log/syslog |grep error | grep -v kernel| grep -i sqlite       - последняя команда - запрос без учета регистра
        :/var/log$ ls -a | sort                                         - открыли каталог log и при просмотре отсортировали по алфовиту
        :~$ df -h | grep '/dev/sda'                                     - открыли сведения о файловой системе и отфильтровали по файловой системе = /dev/sda

## Bash-скрипты
!!! Любой скрипт - это текстовый файл, который имеет права на исполнение
!!! Bash не имеет никакого этапа компиляции, т.к. относится к интерпретируемым языкам
### Переменные и их классификация 
!!! Переменную можно записать и можно прочитать, больше в Bash с переменными никаких действий не производится
!!! У переменных есть ограничения на наименование - нельзя использовать кириллицу, нельзя начинать имя с цифры, нельзя использовать пробел
!!! Если необходимо положить в переменную текст с пробелами между словами, заключаем его в одинарные кавычки
!!! Двойные кавычки мы используем для интерполяции переменных (подставление значения вместо названия переменной)
!!! Для того, чтобы в переменную положить утилиту - необходимо положить команду в скобки и перед ними поставить знак $, либо записать утилиту в бектиках (`) - находится на букве Ё
    Пример:
        :/$ var1='test rreer esthyreujr wetgwt'        - создаст текстовую переменную
        :/$ echo $var1                                 - выведет значение:  test rreer esthyreujr wetgwt
        :/$ var2=Hello                                 - создаст текстовую переменную
        :/$ var3="$var1 $var2"                         - создаст текстовую переменную из значений указанных переменных (благодаря двойным кавычкам)
        :~$ echo $var3                                 - выведет значение:  test rreer esthyreujr wetgwt Hello
- Переменные окружения              - (как правило записываются в верхнем регистре)
    ○ $PATH                         - это переменная среды, используемая для указания оболочке, где искать исполняемые файлы. $PATH обеспечивает большую гибкость и безопасность для систем Linux, и, безусловно, можно сказать, что это одна из самых важных переменных среды. Программы/скрипты, расположенные в каталоге $PATH, могут быть выполнены непосредственно в вашей оболочке без указания полного пути к ним.
    ○ $UID                          - переменная UID обозначает идентификатор пользователя. UID — это номер, назначенный каждому пользователю Linux. Это представление пользователя в ядре Linux.
    ○ $PWD                          - переменная, показывающая текущую рабочую директорию 
        Примеры:
            :/$ echo $PWD           - посмотреть путь текущей директории
            :/$ echo $OLDPWD        - посмотреть путь предыдущей директории

- Пользовательские переменные       - (как правило записываются в нижнем регистре)
!!! Если мы записываем переменную, то знак $ не ставится, а если мы читаем переменную, то смотрим ее значение мы через $
    ○ var1=test                     - назначает строчку 'тест' в качестве значения переменной var1
    ○ echo $var1                    - читает переменную var1 и выводит ее значение в терминал
    ○ var_ls=$(ls -al)              - такая конструкция позволяет утилиту положить в переменную
    ○ var_ls=`ls -al`               - то же самое, что и выше
    ○ echo var_ls                   - выведет список директории, как и команда ls -al, правда весь текст будет положен в одну строчку
- Специальные переменные            - решают задачи внутри скрипта, с помощью них можно передавать параметры в скрипт
    ○ $1…$9
    ○ $?
### Некоторые команды
- printenv      - показывает переменные окружения, которые уже используется. От значений этих переменных зависит то, как будет работать наша оболочка Bash

### Создаём первый скрипт на bash
!!! Все команды пишутся с новой строки, либо разделяются точкой с запятой
cat > testscript
#!/bin/bash             - шибенк строчка (определяет на каком языке мы написали скрипт, т.е. мы выбираем конкретный интерпретатор, который будет исполнять этот код)
directory=$1            - переменная $1 - это первый параметр скрипта, который мы передаем
hidden_count=$(ls -A $directory | grep '^\.' | wc -l)   - в переменную передается конвейер, где при фильтрации используется шаблон '^\.' (^ - начало строки, \. - точка)
echo “Hidden files in $directory found: $hidden_count”  - выводится результат скрипта, в вывод с помощью двойных кавычек, положили 2 переменные

### Методы запуска скрипта
- Относительный путь:               ./testscript
- Абсолютный путь:                  /home/db/test/testscript
- Команда (должен быть в $PATH):    testscript
- Через команду bash:               bash testscript           - мы передаем текстовый файл в bash для его запуска
- Первые три варианта требуют шебанг и права на исполнение (можно добавить бит на исполнение файла, тогда все заработает)
!!! в нашем скрипте есть параметр, передаваемый скрипту при выполнении, сохраненный в directory. Поэтому мы можем посмотреть любую директорию, например /etc, указав ее
    :~$ ./testscript /etc
!!! Если мы не передаем параметром директорию, то скрипт, по умолчанию, берет директорию в которой он запущен

### Однострочные скрипты
- Разделитель команд — ";"
- Удобны для выполнения в терминале             (если не хотим сохранять скрипт - т.к. задача одноразовая)
- Применимы все основные конструкции из bash
- apt update; apt upgrade; echo "Upgrade complete!"

## Циклы и ветвления

### Условия if и ветвления
Синтаксис:
if [ выражение ]                            - пробелы вокруг квадратных скобок обязательны! Иначе выражение работать не будет
    then                                    - отступы от начала строки - необязательны, можно писать сначала новой строки
        Действия, если выражение истинно
    else
        Действия в противоположном случае
fi

    Пример:
    if [ -e file_name ]
    then
        echo "true"
    else
        echo "false"
    fi

    Пример (откорректируем скрипт):
 #!/bin/bash
# First script
if [ -d $1 ]
        then
                echo "Dir Ok"
        else
                echo "No Dir"
                exit 2
fi

directory=$1    # set variable

hidden_count=$(ls -A $directory | grep '^\.' | wc -l)
echo “Hidden files in $directory found: $hidden_count”

# Вывести содержимое переменной
echo “Hidden files in $directory found: $hidden_count”
### Варианты условий
- Операции сравнения строк
    ● = или == возвращает true (истина), если строки равны
    ● != возвращает true (истина), если строки не равны
    ● -z возвращает true (истина), если строка пуста
    ● -n возвращает true (истина), если строка не пуста
- Операции проверки файлов
    ● -e возвращает true (истина), если файл существует (exists)
    ● -d возвращает true (истина), если каталог существует (directory)
- Операции сравнения целых чисел (наиболее используемые)
    ● -eq возвращает true (истина), если числа равны (equals)
    ● -ne возвращает true (истина), если числа не равны (not equal)
- посмотреть команды по сравнению можно в мануале test  (man test)

### Цикл for
Синтаксис:
for имя_переменной in значения
do
    тело_цикла
done

Примеры:
    for h in {01..24}           - можно также записать буквы {a..e} или записать так {a,e}
    do
        echo $h
    done

    for (( c=1; c<=5; c++ ))
    do
        echo "Попытка номер $c"
    done

### Цикл while
Синтаксис:
while [ условие ]
do
    Тело_цикла
done

Пример:
    c=10
    while [ $c -ge 0 ]
    do
        echo "Test $c"
        let "c = c - 1"             - с помощью команды let - производим арифметические действия
    done

### Типы команд
!!! мы иногда используем псевдонимы, какие-то команды являются просто исполняемыми файлами, а иногда мы можем использовать внутренние команды Bash
- type {команда}        - показывает тип данной конкретной команды
    Пример:
        :~$ type ls             - выведет: ls — это псевдонимом для «ls --color=auto»
        :~$ type -a ls          - выведет три строки: ls — это псевдонимом для «ls --color=auto»;  ls является /usr/bin/ls;  ls является /bin/ls
        :~$ type cd             - выведет:  cd — это встроенная команда bash
        :~$ type rm             - выведет:  rm является /usr/bin/rm
        :~$ type for            - выведет:  for — это ключевое слово командного процессора
!!! Если мы точно знаем, что команда является исполняемым файлом, то можно использовать конструкцию:
        :~$ which ls            - выведет путь к указанной команде

        :~$ nano .bashrc        - позволяет посмотреть файл, описывающий оболочку bash и откорректировать его, добавив / убрав какие-то настройки
 
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------

## Урок 5.  Установка пакетов, репозитории. Планировщик Cron
       
## Установка софта в Linux
### Варианты установки ПО в Linux
- Исходный код
    ● требуется компиляция
    ● инструменты разработки
    ● засорение системы
- Скомпилированные файлы
    ● нет централизованного управления
    ● вопрос доверия
- Пакеты
    ● deb, rpm, snap
    ● централизация
    ● удобство
    ● скорость

### Пакетные менеджеры
Тип пакета:
- Пакеты deb:
    ● apt
    ● dpkg 
- Пакеты snap
    ● snap

### Классификация репозиториев
- По разработчику:
    ● Стандартные
    ● Дополнительные
    ● Неофициальные
- По лицензированию:
    ● main – открытое с поддержкой
    ● restricted – проприетарное с поддержкой
    ● universe – открытое без поддержки
    ● multiverse – проприетарное без поддержки
- По версиям ПО:
    ● $release
    ● $release-security
    ● $release-updates
    ● $release-backports

### Подключение дополнительного репозитория
- /etc/apt/sources.list – добавление репозитория в основной файл
- /etc/apt/sources.list.d/*.list – добавление файла с адресом репозитория
- deb http://адрес_репозитория версия_дистрибутива ветки
- deb http://nginx.org/packages/ubuntu jammy nginx
- sudo apt-key add repo.key – добавление ключа репозитория

### Поиск пакетов и репозиториев
- Основные (дистрибутив)
    ● Не требуется усилий
    ● Гарантированная работа
    ● Совместимость
    ● Не всегда свежие версии
- Разработчик ПО
    ● Требуется поддержка дистрибутива и версии
    ● Доверие к разработчику
    ● Возможны конфликты с пакетами дистрибутива
    ● Обычно свежие версии
- PPA (сообщество)
    ● Низкий уровень доверия
    ● Нет поддержки
    ● Выбор в случае отсутствия других вариантов

### Утилита apt
- Автоматизированное управление пакетами с учетом зависимостей
- Работа с удалёнными репозиториями
- apt search package_name — поиск пакета по названию и описанию
- apt list package_name — поиск пакета по имени
- apt show package_name — посмотреть информацию о пакете
- apt install package_name -y — установить пакет
- apt remove package_name — удалить пакет, при этом сохранятся файлы с настройками
- apt autoremove    - удаляет все зависимости (допустим удалили утилиту командой apt remove package_name, а зависимости остались)
- apt purge package_name — полностью удалить пакет, включая конфигурационные файлы
- apt upgrade — обновить все установленные пакеты
- apt update — обновить информацию о пакетах в репозиториях, указанных в настройках (команда выполняется перед apt upgrade)

### Утилита dpkg
- Ручное управление пакетами
- Нет работы с зависимостями
- Локальные пакеты
- dpkg -l — просмотр списка пакетов
- dpkg -i package_name — установить пакет или группу пакетов
    - apt -f install    — исправляет сломанные пакеты (если при выполнении команды dpkg -i package_name возникли проблемы с зависимостями)
- dpkg -r package_name — удалить пакет или группу пакетов

### snap-пакеты
- Все зависимости – в пакете
- Пакет изолирован от системы – разрешения
- Программы запускаются дольше
- Больше потребление ресурсов
- Нет проблем совместимости
- snap search package_name — поиск пакета
- snap install package_name — установка пакета
- snap refresh package_name — обновление пакета
- snap remove package_name — удаление пакета
- snap list — просмотр установленных пакетов

## Планировщик cron

### Планировщик задач cron
- Выполнение регулярных задач по расписанию
- Автоматизация обслуживания системы или приложений
- Системные задачи:
    ○ /etc/crontab
    ○ /etc/cron.d/*
- Пользовательские задачи:
    ○ /var/spool/cron/*
    ○ управление: утилита crontab

### Формат задачи в cron
17 * * * * root cd / && run-parts --report /etc/cron.hourly
- Расписание  (17 * * * *)
    ✖ минуты
    ✖ часы
    ✖ день месяца
    ✖ месяц
    ✖ день недели
    Если надо настроить время, например каждые десять минут, то запись времени будет такая: */10  * * * *
- Пользователь  (root )
    ✖ для выполнения команды
- Команда   (run-parts --report /etc/cron.hourly)
    ✖ для задачи

### Утилита crontab
- crontab - l вывести содержимое текущего файла расписания
- crontab -r удаление текущего файла расписания:
- crontab -e редактирование текущего файла расписания
- sudo crontab -u username – работа с файлом расписания другого пользователя

------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------

## Урок 6.  Сетевые возможности Linux

## Сетевая подсистема в Linux

### Архитектура сетевой подсистемы
Приложение <-> Ядро <-> Сетевая карта

### Сетевые уровни и протоколы
- OSI Basic Reference Model
- Protocols in Each Layer
- TCP/IP Model

### Сетевые интерфейсы и команда ip
- ip a – список всех интерфейсов
- ip -s a – показ статистики
- ip -c -s a – включение подсветки
- ip a show enp0s3 – данные по одному интерфейсу
- ip link show enp0s3 – данные уровня L2 (link)
- ip r – просмотр информации о маршрутах

### Сокеты и порты
- ss – socket stat
- ss -ntlp – TCP-сокеты в состоянии LISTEN
- ss -ntulp – TCP и UDP-сокеты в состоянии LISTEN
- ss -tulpan – Все TCP и UDP-сокеты

### Конфигурация сети в Ubuntu
- Netplan
    - systemd-networkd
    - Network Manager
https://netplan.io/

#### Netplan
- /etc/netplan/*.yaml – конфигурационные файлы
- netplan try – тестирование и применение конфигурации
- netplan apply – применение конфигурации
- Конфигурация по умолчанию:
// Let NetworkManager manage all devices on this system
network:                                    (без пробелов)
 version: 2                                 (+2 пробела)
 renderer: NetworkManager                   (+2 пробела)

 #### Netplan – конфигурация с DHCP
network:
    version: 2                              (+2 пробела)
    renderer: networkd                      (+2 пробела)
    ethernets:                              (+2 пробела)
        enp0s3:                             (+4 пробела)
            dhcp4: yes                      (+6 пробела)
            nameservers:                    (+6 пробела)
                addresses:                  (+8 пробела)
                    - 8.8.8.8               (+10 пробела)
                    - 8.8.4.4               (+10 пробела)

#### Netplan – статическая конфигурация
network:
    version: 2                              (+2 пробела)
    renderer: networkd                      (+2 пробела)
    ethernets:                              (+2 пробела)
        enp0s3:                             (+4 пробела)
            dhcp4: no                       (+6 пробела)
            addresses: [192.168.0.8/24]     (+6 пробела)
            gateway4: 192.168.0.1           (+6 пробела)
            nameservers:                    (+6 пробела)
                addresses:                  (+8 пробела)
                    - 8.8.8.8               (+10 пробела)
                    - 8.8.4.4               (+10 пробела)

### Диагностика сети
- ping 8.8.8.8 – доступность хоста (ICMP протокол)
- ping ya.ru – проверка DNS и доступности
- host -t a yandex.ru – проверка DNS
- host -t a yandex.ru 8.8.8.8 – другой DNS-сервер
- dig @8.8.8.8 google.com – подробная информация по DNS
- tracepath ya.ru – просмотр маршрута прохождения пакетов
- traceroute ya.ru – альтернатива
- mtr ya.ru – постоянный мониторинг доступности хостов

## Фильтрация пакетов
### Правила фильтрации
- Просмотр таблицы
    ○ iptables -L -nv
    ○ iptables -L -nv -t nat
- Политика по умолчанию
    ○ iptables -P INPUT DROP
- Добавление правил
    ○ iptables -A INPUT -p tcp --dport 80 -j ACCEPT
    ○ iptables -I INPUT -p tcp --dport 80 -j ACCEPT
    ○ iptables -A INPUT -p tcp -s 192.168.0.100 --dport 80 -j DROP
- Удаление правил
    ○ iptables -D INPUT 3
    ○ iptables -D INPUT -p tcp --dport 80 -j ACCEPT
- Сброс правил
    ○ iptables -F

### Пример конфигурации сервера
// SSH allow
iptables -A INPUT -p tcp --dport=22 -j ACCEPT
// HTTP, HTTPS allow
iptables -A INPUT -p tcp -m multiport --dport 80,443 -j ACCEPT
// loopback allow
iptables -A INPUT -i lo -j ACCEPT
// ICMP
iptables -A INPUT -p icmp -j ACCEPT
// established connections allow
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
// policy drop
iptables -P INPUT DROP

### Перенаправление портов
- Редирект с 80 на 8080 порт (TCP):
    ○ iptables -t nat -I PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080
- Проверка:
    ○ iptables -L -nv -t nat

### Сохранение конфигурации iptables
- Сохранение и восстановление из файла
    ○ iptables-save > iptables.rules
    ○ iptables-restore < iptables.rules
- Сервис netfilter-persistent
    ○ apt install iptables-persistent netfilter-persistent
    ○ netfilter-persistent save
    ○ Конфигурация в /etc/iptables

------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------

## Урок 7. Веб-сервер на Linux

## Компоненты веб-приложения
Веб-браузер (клиентский код – frontend) < -- HTTP(S) -- >  Веб-сервер (серверный код – backend) < -- >  База данных

### Консольные утилиты для веб
- Получить URL в консоли:
    ○ curl -L https://ya.ru/
    ○ wget https://yastatic.net/jquery/2.1.4/jquery.min.js

### Протоколы SSL/TLS и HTTPS
- SSL — первые версии защищенного протокола
- TLS – современный протокол
- HTTPS – работа протокола HTTP поверх защищенного канала SSL/TLS
- HTTP/2, HTTP/3 – по умолчанию используют защищенный вариант

### Схема работы HTTPS
Веб-браузер --Ключ шифрования--> Веб-сервер
Список доверенных центров (Root CA) <--Проверка сертификата-- Веб-браузер <--Сертификат - site.ru-- Веб-сервер <--Выдача сертификата-- CA–удостоверяющий центр

### Преимущества HTTPS
- Трафик шифруется при передаче
    ○ Нет перехвата данных
    ○ Нельзя изменить содержимое
- Подтверждение соответствия сервера домену
- Надежная доставка через цепочку хостов
- Поддержка новейших веб-технологий

## Веб-сервер Nginx
### Nginx
- Самый популярный сервер в мире
- Высокая производительность
- Масштабируемость по количеству подключений
- Открытый продукт (коммерческий Nginx Plus)
- Широкая функциональность
- Модульная архитектура
- Поддержка новых технологий
- Используется как сервер для статики, прокси, кэширующий сервер
- Не исполняет серверный код веб-приложения
- Разработчик первых версий: Игорь Сысоев

### Конфигурация Nginx
- Установка: sudo apt install nginx
- Тестирование конфигурации: sudo nginx -t
- Применить: sudo systemctl reload nginx
- Конфигурация: /etc/nginx/*
- Основной файл: /etc/nginx/nginx.conf
- Блоки: server {}
- Директивы: server_name site.ru;
- Переменные: $uri
- Документация: http://nginx.org/ru/docs/

### Пример конфигурации Nginx
server {
        listen 80 default_server;
        listen [::]:80 default_server;
        root /var/www/html;
        index index.html index.htm index.nginx-debian.html;
        server_name _;
        location / {
            try_files $uri $uri/ =404;
        }
}

## Веб-сервер Apache
### Веб-сервер Apache
- Популярный веб-сервер
- Открытый продукт
- Максимальная функциональность
- Модульная архитектура
- Разные режимы работы (MPM – prefork, event…)
- Плохая масштабируемость по соединениям (prefork)
- Возможность исполнения серверного кода (модули)
- Исполняет роль backend-сервера
- Документация: https://httpd.apache.org/docs/2.4/en/

### Конфигурация Apache
- Установка: sudo apt install apache2
- Тестирование конфигурации: sudo apachectl -t
- Применить: sudo systemctl reload apache2
- Конфигурация: /etc/apache2/*
- Основной файл: /etc/apache2/apache2.conf
- Блоки: <VirtualHost></VirtualHost>
- Директивы: ServerName site.ru
- Документация: https://httpd.apache.org/docs/2.4/en/

### Пример конфигурации Apache
Listen 8081
<VirtualHost *:8081>
    ServerName www.example.com
    ServerAdmin webmaster@localhost
    DocumentRoot /var/www/html
    ErrorLog /var/log/httpd/error.log
    CustomLog /var/log/httpd/access.log combined
</VirtualHost>

## Динамический и статический контент. Reverse proxy
#### Схема Reverse proxy и типы контента
Веб-браузер --> Nginx (frontend) --> Apache (backend)
- Веб-браузер
    ● Выполняет клиентский код
    ● Отображает интерфейс
- Nginx (frontend)
    ● Обрабатывает соединения
    ● Отдаёт статику (CSS, JS, картинки)
    ● Проксирует динамические запросы
- Apache (backend)
    ● Обрабатывает динамические запросы
    ● Исполняет серверный код (PHP, Perl, Python)
    ● Возвращает ответ Nginx

### Пример конфигурации Nginx для Reverse proxy
##### Динамические запросы
location / {
    proxy_pass http://localhost:8080;
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Real-IP $remote_addr;
}
##### Статические запросы
location ~* ^.+.(jpg|jpeg|gif|png|ico|css|zip|pdf|txt|tar|js)$ {
 root /var/www/html;
}

### Обработка PHP в Apache
- Установка: apt install libapache2-mod-php8.1 php8.1
- Обработка PHP подключается автоматически, по расширению файла
- Файл для проверки:
    <?php
    phpinfo();
    ?>
- Проверяем: curl http://localhost/info.php

### Обработка PHP в PHP-FPM
- Установка: apt install php8.1-fpm
- Замена Apache для работы с PHP
- Связь между Nginx и PHP-FPM через UNIX-сокет
- Обработка происходит с помощью location в Nginx
    location ~ \.php$ {
        include snippets/fastcgi-php.conf;
        root /var/www/html;
        fastcgi_pass unix:/run/php/php8.1-fpm.sock;
    }

## Система управления базами данных MySQL
### СУБД MySQL
- Самая популярная СУБД для веб-приложений
- Клиент-серверная архитектура
- Несколько веток развития:
    ○ Oracle MySQL
    ○ Percona Server for MySQL
    ○ MariaDB
- Поддержка транзакций
- Репликация
- Поддерживает синтаксис SQL с расширениями
- Документация: https://dev.mysql.com/doc/refman/8.0/en/

### Установка MySQL и первые шаги
- Установка: apt install mysql-server-8.0
- Заходим в консоль MySQL: sudo mysql
- Переходим в системную БД mysql: use mysql;
- Получаем список пользователей: SELECT * FROM user\G
- Создаём новую базу данных: CREATE DATABASE gb;
- Создаём таблицу: CREATE TABLE test(i INT);
- Создадим записи в таблице: INSERT INTO test (i) VALUES (1),(2),(3),(4);
- Сделаем выборку из таблицы: SELECT * FROM test;

------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------

## Урок 8. Основы Docker
## Контейнеризация
### Архитектура контейнеров
Ядро Linux  <-->    Контейнер (библиотеки, приложения)
            <-->    Контейнер (библиотеки, приложения)
            <-->    Системные библиотеки    <-->    Приложения

### Контейнеризация
- Быстрое развёртывание приложений из образов
- Полная повторяемость при запуске (надёжность)
- Высокая скорость запуска и удаления контейнеров
- Низкие накладные расходы на виртуализацию
- Возможность преодоления несовместимости софта и ОС
- Автоматизация операций управления приложениями

### Виртуализация и контейнеризация
- Container (Docker)
- Virtual Machines

### Реестр образов Docker Hub
- Реестр по умолчанию в Docker
- Веб-интерфейс: https://hub.docker.com/
- Официальные образы (official image)
- Теги (latest, 0.4-alpine)
- Документация к образам

### Запуск тестового контейнера
- Установка Docker: apt install docker.io
- Проверка: sudo docker
- Создание и запуск контейнера: docker run hello-world

### Базовые операции
- docker ps – просмотр активных контейнеров
- docker ps -a – просмотр всех контейнеров
- docker images – список образов
- docker search nginx – поиск образа
- docker pull nginx – скачивание образа
- docker start|restart|stop nginx – операции с контейнером
- docker rm 9cbf7c3230d0 – удаление контейнера
- docker rmi hello-world – удаление образа
- docker logs nginx1 – просмотр логов контейнера

### Типы сетей в Docker
- Bridge — сети по умолчанию, аналог типа подключения NAT в VirtualBox.
- Host — с помощью этого драйвера контейнер получает доступ к собственному интерфейсу хоста. Аналог подключения «Мост» в VirtualBox.
- Macvlan даёт контейнерам прямой доступ к интерфейсу и субинтерфейсу (VLAN) хоста.
- Overlay позволяет строить сети на нескольких хостах с Docker.

### Проброс портов и host-сеть в Docker
- Docker bridge — проброс портов:
    Клиент <--> TCP 80  <--> Контейнер Nginx (TCP 80)
- Docker host — прямой доступ:
     Клиент <--> Контейнер Nginx (TCP 80)

### Тома и монтирование в Docker
- Bind mount (монтирование)
    /var/www/   <-->    Контейнер Nginx (/var/nginx)
- Docker volume (том Docker)
    /var/lib/docker/volumes/xxxxx   <-->    Контейнер Nginx (/var/nginx)

## Запуск Nginx в контейнере
### Запуск Nginx – проброс портов и директории
- Команда создания и запуска: docker run -d --restart always --name nginx1 \
        -p 80:80 -v /var/www/html:/usr/share/nginx/html nginx
- Учитываем порты на хосте (ss -ntlp)
- Монтируем директории
- Активируем автозапуск
- Контейнер работает в режиме демона
- Сеть по умолчанию (bridge)

### Работа внутри контейнера
- Не рекомендуется в реальной работе
- Заходим: docker exec -ti nginx1 bash
- Смотрим настройки: ls -al /etc/
- Версия базового дистрибутива: cat /etc/os-release
- Настройки nginx: ls -al /etc/nginx/
- Директория сайта: ls -al /usr/share/nginx/html

## Docker Compose
### Docker Compose
- Запуск нескольких контейнеров одной командой
- Декларативная конфигурация
- Формат YAML (отступы, вложенность)
- Автоматизация запуска систем контейнеров 

### Синтаксис docker-compose.yml
version: '3'
services:
    wordpress:
    depends_on:
        - db
    image: wordpress:5.3.2-fpm-alpine
    container_name: wordpress
    environment:
        - WORDPRESS_DB_HOST=db:3306
    volumes:
        - wordpress:/var/www/html
    networks:
        - app-network

### Использование Docker Compose
- apt install docker-compose – установка
- Проверка yml: apt install yamllint
- docker-compose up -d – создание и запуск
- docker-compose ps – список контейнеров
- docker-compose down – остановить и удалить
- docker-compose stop – остановить
- docker-compose start – запустить
- docker-compose rm – удалить остановленные